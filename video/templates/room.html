<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Zoom-like Video Call</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    :root {
      --primary-color: #2d8cff;
      --danger-color: #ff3d3d;
      --dark-color: #202124;
      --light-color: #f8f9fa;
    }
    
    body {
      background-color: #f0f2f5;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    .video-container {
      position: relative;
      width: 100%;
      height: 0;
      padding-bottom: 56.25%; /* 16:9 aspect ratio */
      background-color: #000;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    
    video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .video-label {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 10;
    }
    
    .controls-container {
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      z-index: 1000;
    }
    
    .controls {
      background-color: white;
      padding: 10px 20px;
      border-radius: 30px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      display: flex;
      gap: 10px;
    }
    
    .btn-control {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      border: none;
      transition: all 0.2s;
    }
    
    .btn-control:hover {
      transform: scale(1.05);
    }
    
    .btn-primary {
      background-color: var(--primary-color);
      color: white;
    }
    
    .btn-danger {
      background-color: var(--danger-color);
      color: white;
    }
    
    .btn-secondary {
      background-color: #e4e6eb;
      color: #050505;
    }
    
    .meeting-info {
      position: fixed;
      top: 20px;
      left: 20px;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 1000;
    }
    
    .participant-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      padding: 20px;
    }
    
    .participant {
      position: relative;
    }
    
    .muted-indicator {
      position: absolute;
      bottom: 40px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 10;
    }
    
    .fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2000;
      background-color: black;
    }
    
    .fullscreen video {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    
    .fullscreen .video-label {
      font-size: 16px;
    }
    
    .connection-status {
      position: fixed;
      top: 70px;
      left: 20px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 1000;
    }
    
    .status-connecting {
      color: #ffc107;
    }
    
    .status-connected {
      color: #28a745;
    }
    
    .status-error {
      color: #dc3545;
    }
  </style>
</head>
<body>
  <div class="connection-status" id="connectionStatus">
    <i class="fas fa-circle status-connecting"></i> Initializing...
  </div>

  <div class="container-fluid p-0">
    <div class="participant-grid" id="videoGrid">
    
    </div>
  </div>

  <div class="controls-container">
    <div class="controls">
      <button id="toggleMicBtn" class="btn-control btn-secondary" title="Mute">
        <i class="fas fa-microphone"></i>
      </button>
      <button id="toggleCamBtn" class="btn-control btn-secondary" title="Stop Video">
        <i class="fas fa-video"></i>
      </button>
      <button id="callBtn" class="btn-control btn-primary" title="Start Call" style="display: none;">
        <i class="fas fa-phone"></i>
      </button>
      <button id="hangupBtn" class="btn-control btn-danger" title="End Call" style="display: none;">
        <i class="fas fa-phone-slash"></i>
      </button>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
   
    const config = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:stun2.l.google.com:19302" }
      ],
      mediaConstraints: {
        video: {
          width: { ideal: 1280 },
          height: { ideal: 720 },
          frameRate: { ideal: 30 }
        },
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        }
      }
    };

  
    const videoGrid = document.getElementById('videoGrid');
    const connectionStatus = document.getElementById('connectionStatus');
    const callBtn = document.getElementById('callBtn');
    const hangupBtn = document.getElementById('hangupBtn');
    const toggleMicBtn = document.getElementById('toggleMicBtn');
    const toggleCamBtn = document.getElementById('toggleCamBtn');


    let localStream;
    let peerConnection;
    let isRoomCreator = false;
    let isMuted = false;
    let isVideoOff = false;
    let participants = {};
    let isCallActive = false;

    let ws = null;
    let simulateConnection = true;


    async function initialize() {
      try {
        updateConnectionStatus('Accessing camera and microphone...', 'connecting');
        await initializeLocalStream();
        updateConnectionStatus('Ready to start call', 'connected');
        callBtn.style.display = 'flex';
      } catch (error) {
        console.error('Initialization error:', error);
        updateConnectionStatus('Error: Could not access media devices', 'error');
        handleMediaError(error);
      }
    }

  
    function updateConnectionStatus(message, status) {
      const statusEl = document.getElementById('connectionStatus');
      const iconClass = status === 'connecting' ? 'status-connecting' : 
                       status === 'connected' ? 'status-connected' : 'status-error';
      statusEl.innerHTML = `<i class="fas fa-circle ${iconClass}"></i> ${message}`;
    }


    async function initializeLocalStream() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia(config.mediaConstraints);
        addLocalVideo(localStream);
       
        localStream.getTracks().forEach(track => {
          track.addEventListener('ended', () => {
            console.log('Track ended:', track.kind);
            handleTrackEnded(track);
          });
        });
        
        return localStream;
      } catch (error) {
        console.error("Error accessing media devices:", error);
        throw error;
      }
    }

    function handleMediaError(error) {
      let message = "Could not access camera/microphone. ";
      
      if (error.name === 'NotAllowedError') {
        message += "Please allow camera and microphone permissions and refresh the page.";
      } else if (error.name === 'NotFoundError') {
        message += "No camera or microphone found.";
      } else if (error.name === 'NotReadableError') {
        message += "Camera or microphone is already in use.";
      } else {
        message += "Please check your device settings.";
      }
      
      alert(message);
    }

    function handleTrackEnded(track) {
      if (track.kind === 'video') {
        console.log('Video track ended');
      }
    }

    async function toggleScreenShare() {
      
      console.log('Screen sharing not available');
    }

    function addLocalVideo(stream) {
      
      const existingLocal = document.getElementById('localVideo');
      if (existingLocal) {
        existingLocal.remove();
      }

      const videoElement = createVideoElement('You', stream, true);
      videoElement.setAttribute('id', 'localVideo');
      videoGrid.prepend(videoElement);
    }

    function updateLocalVideo(stream) {
      const localVideo = document.getElementById('localVideo');
      if (localVideo) {
        const videoEl = localVideo.querySelector('video');
        if (videoEl) {
          videoEl.srcObject = stream;
        }
      }
    }

    function addRemoteVideo(userId, stream) {
      if (!participants[userId]) {
        const videoElement = createVideoElement(`Participant ${Object.keys(participants).length + 1}`, stream, false);
        videoElement.setAttribute('id', `remoteVideo_${userId}`);
        videoGrid.appendChild(videoElement);
        participants[userId] = { element: videoElement, stream };
      }
    }

    function removeParticipant(userId) {
      if (participants[userId]) {
        participants[userId].element.remove();
        delete participants[userId];
        renumberParticipants();
      }
    }

    function renumberParticipants() {
      let index = 1;
      for (const userId in participants) {
        const label = participants[userId].element.querySelector('.video-label');
        if (label) {
          label.textContent = `Participant ${index}`;
        }
        index++;
      }
    }

    function createVideoElement(name, stream, isLocal) {
      const videoContainer = document.createElement('div');
      videoContainer.className = 'participant';
      
      const videoWrapper = document.createElement('div');
      videoWrapper.className = 'video-container';
      
      const videoElement = document.createElement('video');
      videoElement.autoplay = true;
      videoElement.playsInline = true;
      videoElement.muted = isLocal;
   
      videoElement.addEventListener('loadedmetadata', () => {
        videoElement.play().catch(error => {
          console.error('Error playing video:', error);
        });
      });
      
      if (stream) {
        videoElement.srcObject = stream;
      }
      
      const label = document.createElement('div');
      label.className = 'video-label';
      label.textContent = name;
      
      videoWrapper.appendChild(videoElement);
      videoWrapper.appendChild(label);
      videoContainer.appendChild(videoWrapper);
      
      videoWrapper.addEventListener('dblclick', () => {
        toggleFullScreen(videoContainer);
      });
      
      return videoContainer;
    }

    function toggleFullScreen(element) {
      if (element.classList.contains('fullscreen')) {
        element.classList.remove('fullscreen');
      } else {
        document.querySelectorAll('.fullscreen').forEach(el => el.classList.remove('fullscreen'));
        element.classList.add('fullscreen');
      }
    }

    async function createPeerConnection() {
      try {
        peerConnection = new RTCPeerConnection(config);
        
   
        if (localStream) {
          localStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
          });
        }
        
       
        peerConnection.addEventListener('connectionstatechange', () => {
          console.log('Connection state:', peerConnection.connectionState);
          updateConnectionStatus(`Connection: ${peerConnection.connectionState}`, 
                               peerConnection.connectionState === 'connected' ? 'connected' : 'connecting');
        });

        peerConnection.addEventListener('track', (event) => {
          console.log('Received remote track:', event);
          const userId = 'remote_' + Date.now();
          addRemoteVideo(userId, event.streams[0]);
        });

        return peerConnection;
      } catch (error) {
        console.error('Error creating peer connection:', error);
        throw error;
      }
    }

    async function startCall() {
      if (!localStream) {
        alert('Camera not available');
        return;
      }

      try {
        updateConnectionStatus('Starting call...', 'connecting');
        
        
        isCallActive = true;
        callBtn.style.display = 'none';
        hangupBtn.style.display = 'flex';
        
       
        setTimeout(() => {
          simulateRemoteParticipant();
          updateConnectionStatus('Call active', 'connected');
        }, 2000);
        
      } catch (error) {
        console.error('Error starting call:', error);
        updateConnectionStatus('Error starting call', 'error');
        isCallActive = false;
        callBtn.style.display = 'flex';
        hangupBtn.style.display = 'none';
      }
    }

    async function simulateRemoteParticipant() {
      try {
       
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        
        if (videoDevices.length > 1) {
         
          const secondCameraStream = await navigator.mediaDevices.getUserMedia({
            video: { deviceId: videoDevices[1].deviceId },
            audio: false
          });
          addRemoteVideo('second_camera', secondCameraStream);
          return;
        }
      } catch (error) {
        console.log('Could not access second camera, using canvas simulation');
      }
      
      const canvas = document.createElement('canvas');
      canvas.width = 640;
      canvas.height = 480;
      const ctx = canvas.getContext('2d');
      
      
      let time = 0;
      const drawFrame = () => {
       
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#1a1a2e');
        gradient.addColorStop(0.5, '#16213e');
        gradient.addColorStop(1, '#0f3460');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
       
        ctx.beginPath();
        ctx.arc(canvas.width/2, canvas.height/2 - 50, 60, 0, 2 * Math.PI);
        ctx.fillStyle = '#4a90e2';
        ctx.fill();
       
        ctx.fillStyle = 'white';
        ctx.font = 'bold 40px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('RP', canvas.width/2, canvas.height/2 - 40);
        
       
        ctx.font = '20px Arial';
        ctx.fillText('Remote Participant', canvas.width/2, canvas.height/2 + 40);
        
      
        ctx.fillStyle = `rgba(74, 144, 226, ${0.3 + 0.2 * Math.sin(time * 0.05)})`;
        ctx.beginPath();
        ctx.arc(canvas.width/2, canvas.height/2 - 50, 65, 0, 2 * Math.PI);
        ctx.fill();
        
        time++;
      };
      
    
      setInterval(drawFrame, 33);
      drawFrame();
      
      const fakeStream = canvas.captureStream(30);
      addRemoteVideo('demo_participant', fakeStream);
    }

   
    function handleHangUp() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      
      
      for (const userId in participants) {
        removeParticipant(userId);
      }
      
    
      isCallActive = false;
      hangupBtn.style.display = 'none';
      callBtn.style.display = 'flex';
      
     
      
      updateConnectionStatus('Call ended', 'connected');
    }

    async function toggleMicrophone() {
      if (localStream) {
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
          audioTrack.enabled = !audioTrack.enabled;
          isMuted = !audioTrack.enabled;
          
          toggleMicBtn.innerHTML = isMuted ? '<i class="fas fa-microphone-slash"></i>' : '<i class="fas fa-microphone"></i>';
          toggleMicBtn.title = isMuted ? 'Unmute' : 'Mute';
          toggleMicBtn.className = `btn-control ${isMuted ? 'btn-danger' : 'btn-secondary'}`;
        }
      }
    }

    async function toggleCamera() {
      if (localStream) {
        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
          videoTrack.enabled = !videoTrack.enabled;
          isVideoOff = !videoTrack.enabled;
          
          toggleCamBtn.innerHTML = isVideoOff ? '<i class="fas fa-video-slash"></i>' : '<i class="fas fa-video"></i>';
          toggleCamBtn.title = isVideoOff ? 'Start Video' : 'Stop Video';
          toggleCamBtn.className = `btn-control ${isVideoOff ? 'btn-danger' : 'btn-secondary'}`;
        }
      }
    }

   
    callBtn.addEventListener('click', startCall);
    hangupBtn.addEventListener('click', handleHangUp);
    toggleMicBtn.addEventListener('click', toggleMicrophone);
    toggleCamBtn.addEventListener('click', toggleCamera);

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        console.log('Page hidden');
      } else {
        console.log('Page visible');
      }
    });

 
    window.addEventListener('beforeunload', () => {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
    });

  
    window.addEventListener('load', initialize);
  </script>
</body>
</html>